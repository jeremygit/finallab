/*! @file packet.c
 *
 *  @brief Implement packet encoding and decoding for the serial port.
 *
 *  Implementing of the functionality for "Tower to PC Protocol" 5-byte packets.
 *
 *  @author Author: Jeremy Heritage 12033445 , Victor WU (12009155)
 *
 *  @date Created on: 29 Mar 2017, Last updated 01 April 2017
 */
/*!
**  @addtogroup Packet_module Packet module documentation
**  @{
*/
/* MODULE Packet */

// Import the Packet header
#include "packet.h"
// Import the UART Module
#include "UART.h"

#include "OS.h"

#include "Cpu.h"


// Initialized as 0
TPacket Packet;

const uint8_t PACKET_ACK_MASK = 0x80u;	/*!< Initialize the PACKET_ACK_MASK to 1000 0000 */

OS_ECB *PacketNotInUseSemaphore;

/*! @brief Carries out the protocols checksum algorithm.
 *  @return uint8_t - A Packet byte generated by the XOR operation of the 4 other Packet bytes.
 */
static uint8_t Checksum(const uint8_t command, const uint8_t parameter1, const uint8_t parameter2, const uint8_t parameter3);


bool Packet_Init(const uint32_t baudRate, const uint32_t moduleClk)
{
  PacketNotInUseSemaphore = OS_SemaphoreCreate(1);
  return UART_Init(baudRate, moduleClk);
}

bool Packet_Get(void)
{
  // While we have bytes in the UART buffer, attempt to construct a packet.
  /*
  while(UART_InChar(&Packet_Checksum))
  {
    // Check if the last received byte constitutes a valid packet by comparing checksums.
    if (Packet_Checksum == Checksum(Packet_Command, Packet_Parameter1, Packet_Parameter2, Packet_Parameter3))
      return 1;

    // If a valid packet has yet to be constructed,
    // shift the position of the already received packet bytes
    // and put the last received byte in parameter 3 position
    // to prepare to check this packet structure against the next received checksum byte.
    Packet_Command = Packet_Parameter1;
    Packet_Parameter1 = Packet_Parameter2;
    Packet_Parameter2 = Packet_Parameter3;
    Packet_Parameter3 = Packet_Checksum;
  }

  // The buffer was empty, and we weren't able to construct a valid packet.
  return 0;
  */

  static int state = 0;

  switch(state)
  {
    case 0:
      UART_InChar(&Packet_Command);
      state = 1;
      break;

    case 1:
      UART_InChar(&Packet_Parameter1);
      state = 2;
      break;

    case 2:
      UART_InChar(&Packet_Parameter2);
      state = 3;
      break;

    case 3:
      UART_InChar(&Packet_Parameter3);
      state = 4;
      break;

    case 4:
      UART_InChar(&Packet_Checksum);
      state = 5;
      break;

    case 5:
      if (Packet_Checksum == Packet_Command ^ Packet_Parameter1 ^ Packet_Parameter2 ^ Packet_Parameter3) {
	state = 0;
	return true;
      }
      else
      {
	// Checksum executed and error is detected, right shift bytes.
	Packet_Command = Packet_Parameter1;
	Packet_Parameter1 = Packet_Parameter2;
	Packet_Parameter2 = Packet_Parameter3;
	Packet_Parameter3 = Packet_Checksum;
	state = 4; //Return to the state for to test for Checksum again.
	return false;
      }
  }
  return false;

}

bool Packet_Put(const uint8_t command, const uint8_t parameter1, const uint8_t parameter2, const uint8_t parameter3) {

  // Attempt to place the packets in the buffer in the correct order for UART transmission.
  // OS_DisableInterrupts();

  // Lock the module from other modules trying to Put Packets
  // to preserve the order of bytes in he UART FIFO buffer
  OS_SemaphoreWait(PacketNotInUseSemaphore, 0);
  UART_OutChar(command);
  UART_OutChar(parameter1);
  UART_OutChar(parameter2);
  UART_OutChar(parameter3);
  UART_OutChar(Checksum(command, parameter1, parameter2, parameter3));
  OS_SemaphoreSignal(PacketNotInUseSemaphore);
  return true;
}

static uint8_t Checksum(const uint8_t command, const uint8_t parameter1, const uint8_t parameter2, const uint8_t parameter3)
{
  return command ^ parameter1 ^ parameter2 ^ parameter3;
}

/*!
** @}
*/
